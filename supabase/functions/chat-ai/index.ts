import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface Message {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

interface Character {
  name: string;
  mentions: number;
  facts: string[];
}

interface Event {
  name: string;
  mentions: number;
  details: string[];
}

interface Topic {
  name: string;
  mentions: number;
  info: string[];
}

interface Relationship {
  id: string;
  from_character: string;
  to_character: string;
  type: string;
  description: string;
  strength: number;
}

interface KnowledgeBase {
  characters: { [key: string]: Character };
  events: { [key: string]: Event };
  topics: { [key: string]: Topic };
  relationships: Relationship[];
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { messages, userId, activeCharacter } = await req.json();
    const LOVABLE_API_KEY = Deno.env.get('LOVABLE_API_KEY');
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    
    if (!LOVABLE_API_KEY) {
      throw new Error('LOVABLE_API_KEY is not configured');
    }

    if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
      throw new Error('Supabase credentials not configured');
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Load knowledge base from database
    const kb = await loadKnowledgeBase(supabase, userId);
    const lastUserMessage = messages[messages.length - 1]?.content || '';

    if (lastUserMessage.startsWith('/summary')) {
      const target = lastUserMessage.split(' ')[1] || 'all';
      const summary = generateSummary(kb, target);
      return new Response(
        JSON.stringify({ response: summary, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (lastUserMessage.startsWith('/facts')) {
      const target = lastUserMessage.split(' ')[1] || 'all';
      const facts = generateFacts(kb, target);
      return new Response(
        JSON.stringify({ response: facts, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (lastUserMessage.startsWith('/create')) {
      const params = lastUserMessage.slice(8).trim();
      const result = await createCharacter(supabase, userId, params);
      return new Response(
        JSON.stringify({ response: result, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (lastUserMessage.startsWith('/link')) {
      const params = lastUserMessage.slice(6).trim();
      const result = await createLink(supabase, userId, params, kb);
      return new Response(
        JSON.stringify({ response: result, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (lastUserMessage.startsWith('/analyze')) {
      const result = analyzeGraph(kb);
      return new Response(
        JSON.stringify({ response: result, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (lastUserMessage.startsWith('/export')) {
      const exportData = JSON.stringify(kb, null, 2);
      return new Response(
        JSON.stringify({ response: `üì¶ –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö:\n\`\`\`json\n${exportData}\n\`\`\``, shouldShowKeyboard: false }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    let systemPrompt = activeCharacter 
      ? await generateCharacterPrompt(supabase, userId, activeCharacter, kb)
      : `–¢—ã ‚Äî AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç —Å –¥–æ–ª–≥–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é. –¢–≤–æ—è –∑–∞–¥–∞—á–∞:

1. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ä–∞–∑–≥–æ–≤–æ—Ä –∏ –≤—ã—è–≤–ª—è–π:
   - –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π (–ª—é–¥–µ–π, –∫–æ—Ç–æ—Ä—ã—Ö —É–ø–æ–º–∏–Ω–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å)
   - –°–æ–±—ã—Ç–∏—è (–≤—Å—Ç—Ä–µ—á–∏, –ø—Ä–æ–µ–∫—Ç—ã, –∑–∞–¥–∞—á–∏)
   - –¢–µ–º—ã (–∏–Ω—Ç–µ—Ä–µ—Å—ã, —Ö–æ–±–±–∏, –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è)

2. –ó–∞–ø–æ–º–∏–Ω–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ñ–∞–∫—Ç—ã:
   - –û –ø–µ—Ä—Å–æ–Ω–∞–∂–∞—Ö: –∏–º–µ–Ω–∞, –¥–æ–ª–∂–Ω–æ—Å—Ç–∏, –æ—Ç–Ω–æ—à–µ–Ω–∏—è, —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
   - –û —Å–æ–±—ã—Ç–∏—è—Ö: –¥–∞—Ç—ã, –º–µ—Å—Ç–∞, —É—á–∞—Å—Ç–Ω–∏–∫–∏, –¥–µ—Ç–∞–ª–∏
   - –û —Ç–µ–º–∞—Ö: –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å—ã

3. –ò—Å–ø–æ–ª—å–∑—É–π –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ:
   - –í—Å–ø–æ–º–∏–Ω–∞–π —Ä–∞–Ω–µ–µ —É–ø–æ–º—è–Ω—É—Ç—ã–µ —Ñ–∞–∫—Ç—ã
   - –°–≤—è–∑—ã–≤–∞–π –Ω–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π
   - –ë—É–¥—å –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–º –∫ –¥–µ—Ç–∞–ª—è–º

4. –ë—É–¥—å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º, –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–º –∏ –ø—Ä–æ—è–≤–ª—è–π —ç–º–ø–∞—Ç–∏—é.

5. –ï—Å–ª–∏ –≤–æ–ø—Ä–æ—Å –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–≤–µ—Ç (–¥–∞/–Ω–µ—Ç/–≤–æ–∑–º–æ–∂–Ω–æ), –¥–æ–±–∞–≤—å [SHOW_KEYBOARD].

üìä –¢–µ–∫—É—â–∞—è –±–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:

${formatKnowledgeBase(kb)}

–ò—Å–ø–æ–ª—å–∑—É–π —ç—Ç–∏ –∑–Ω–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ. –í—Å–ø–æ–º–∏–Ω–∞–π –¥–µ—Ç–∞–ª–∏ –æ –ª—é–¥—è—Ö –∏ —Å–æ–±—ã—Ç–∏—è—Ö, –∫–æ—Ç–æ—Ä—ã–µ —É–ø–æ–º–∏–Ω–∞–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å.`;
    
    if (!activeCharacter) {
      systemPrompt += '\n\nüí° –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n/create <–∏–º—è> <–æ–ø–∏—Å–∞–Ω–∏–µ> - —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞\n/link <–æ—Ç> > <–∫> <—Ç–∏–ø> - —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑—å\n/analyze - –∞–Ω–∞–ª–∏–∑ –≥—Ä–∞—Ñ–∞ —Å–≤—è–∑–µ–π\n/export - —ç–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö';
    }

    // First call: Get AI response and extract knowledge
    const extractResponse = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${LOVABLE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: '–ò–∑–≤–ª–µ–∫–∏ –∏–∑ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞—Ö, —Å–æ–±—ã—Ç–∏—è—Ö –∏ —Ç–µ–º–∞—Ö.' },
          ...messages,
        ],
        tools: [{
          type: 'function',
          function: {
            name: 'extract_knowledge',
            description: '–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞—Ö, —Å–æ–±—ã—Ç–∏—è—Ö –∏ —Ç–µ–º–∞—Ö –∏–∑ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞',
            parameters: {
              type: 'object',
              properties: {
                characters: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      name: { type: 'string', description: '–ò–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞' },
                      facts: { 
                        type: 'array', 
                        items: { type: 'string' },
                        description: '–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ñ–∞–∫—Ç—ã –æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ (–ø—Ä–æ—Ñ–µ—Å—Å–∏—è, –æ—Ç–Ω–æ—à–µ–Ω–∏—è, —Ö–∞—Ä–∞–∫—Ç–µ—Ä)' 
                      }
                    }
                  }
                },
                events: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      name: { type: 'string', description: '–ù–∞–∑–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è' },
                      details: { 
                        type: 'array', 
                        items: { type: 'string' },
                        description: '–î–µ—Ç–∞–ª–∏ —Å–æ–±—ã—Ç–∏—è (–¥–∞—Ç–∞, –º–µ—Å—Ç–æ, —É—á–∞—Å—Ç–Ω–∏–∫–∏)' 
                      }
                    }
                  }
                },
                topics: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      name: { type: 'string', description: '–¢–µ–º–∞ –∏–ª–∏ –∏–Ω—Ç–µ—Ä–µ—Å' },
                      info: { 
                        type: 'array', 
                        items: { type: 'string' },
                        description: '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–º–µ (–ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è, –º–Ω–µ–Ω–∏—è)' 
                      }
                    }
                  }
                }
              }
            }
          }
        }],
        tool_choice: { type: 'function', function: { name: 'extract_knowledge' } }
      }),
    });

    if (!extractResponse.ok) {
      console.error('Knowledge extraction error:', extractResponse.status);
    } else {
      const extractData = await extractResponse.json();
      const toolCall = extractData.choices[0]?.message?.tool_calls?.[0];
      
      if (toolCall?.function?.arguments) {
        try {
          const knowledge = JSON.parse(toolCall.function.arguments);
          await saveExtractedKnowledge(supabase, userId, kb, knowledge);
        } catch (e) {
          console.error('Failed to parse knowledge:', e);
        }
      }
    }

    // Second call: Generate response
    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${LOVABLE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: systemPrompt },
          ...messages,
        ],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('AI Gateway error:', response.status, errorText);
      throw new Error(`AI Gateway error: ${response.status}`);
    }

    const data = await response.json();
    const aiResponse = data.choices[0]?.message?.content || '–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å.';

    const shouldShowKeyboard = aiResponse.includes('[SHOW_KEYBOARD]');
    const cleanResponse = aiResponse.replace('[SHOW_KEYBOARD]', '').trim();

    return new Response(
      JSON.stringify({ response: cleanResponse, shouldShowKeyboard }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error in chat-ai function:', error);
    return new Response(
      JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

async function loadKnowledgeBase(supabase: any, userId: string): Promise<KnowledgeBase> {
  const kb: KnowledgeBase = {
    characters: {},
    events: {},
    topics: {},
    relationships: [],
  };

  // Load characters
  const { data: characters } = await supabase
    .from('characters')
    .select('*')
    .eq('user_id', userId);

  if (characters) {
    characters.forEach((char: any) => {
      kb.characters[char.name] = {
        name: char.name,
        mentions: char.mentions,
        facts: char.facts || [],
      };
    });
  }

  // Load events
  const { data: events } = await supabase
    .from('events')
    .select('*')
    .eq('user_id', userId);

  if (events) {
    events.forEach((evt: any) => {
      kb.events[evt.name] = {
        name: evt.name,
        mentions: evt.mentions,
        details: evt.details || [],
      };
    });
  }

  // Load topics
  const { data: topics } = await supabase
    .from('topics')
    .select('*')
    .eq('user_id', userId);

  if (topics) {
    topics.forEach((topic: any) => {
      kb.topics[topic.name] = {
        name: topic.name,
        mentions: topic.mentions,
        info: topic.info || [],
      };
    });
  }

  // Load relationships
  const { data: relationships } = await supabase
    .from('relationships')
    .select(`
      id,
      relationship_type,
      description,
      strength,
      from:characters!relationships_from_character_id_fkey(name),
      to:characters!relationships_to_character_id_fkey(name)
    `)
    .eq('user_id', userId);

  if (relationships) {
    kb.relationships = relationships.map((rel: any) => ({
      id: rel.id,
      from_character: rel.from?.name || '',
      to_character: rel.to?.name || '',
      type: rel.relationship_type,
      description: rel.description || '',
      strength: rel.strength || 5,
    }));
  }

  return kb;
}

async function saveExtractedKnowledge(
  supabase: any,
  userId: string,
  kb: KnowledgeBase,
  knowledge: any
) {
  // Save characters with facts
  if (knowledge.characters && Array.isArray(knowledge.characters)) {
    for (const char of knowledge.characters) {
      if (!char.name) continue;
      
      const existing = kb.characters[char.name] || { name: char.name, mentions: 0, facts: [] };
      const newFacts = char.facts || [];
      const allFacts = [...new Set([...existing.facts, ...newFacts])];
      
      kb.characters[char.name] = {
        name: char.name,
        mentions: existing.mentions + 1,
        facts: allFacts
      };

      await supabase
        .from('characters')
        .upsert({
          user_id: userId,
          name: char.name,
          mentions: kb.characters[char.name].mentions,
          facts: kb.characters[char.name].facts,
        }, {
          onConflict: 'user_id,name',
        });
    }
  }

  // Save events with details
  if (knowledge.events && Array.isArray(knowledge.events)) {
    for (const evt of knowledge.events) {
      if (!evt.name) continue;
      
      const eventName = evt.name.toLowerCase();
      const existing = kb.events[eventName] || { name: eventName, mentions: 0, details: [] };
      const newDetails = evt.details || [];
      const allDetails = [...new Set([...existing.details, ...newDetails])];
      
      kb.events[eventName] = {
        name: eventName,
        mentions: existing.mentions + 1,
        details: allDetails
      };

      await supabase
        .from('events')
        .upsert({
          user_id: userId,
          name: eventName,
          mentions: kb.events[eventName].mentions,
          details: kb.events[eventName].details,
        }, {
          onConflict: 'user_id,name',
        });
    }
  }

  // Save topics with info
  if (knowledge.topics && Array.isArray(knowledge.topics)) {
    for (const topic of knowledge.topics) {
      if (!topic.name) continue;
      
      const topicName = topic.name.toLowerCase();
      const existing = kb.topics[topicName] || { name: topicName, mentions: 0, info: [] };
      const newInfo = topic.info || [];
      const allInfo = [...new Set([...existing.info, ...newInfo])];
      
      kb.topics[topicName] = {
        name: topicName,
        mentions: existing.mentions + 1,
        info: allInfo
      };

      await supabase
        .from('topics')
        .upsert({
          user_id: userId,
          name: topicName,
          mentions: kb.topics[topicName].mentions,
          info: kb.topics[topicName].info,
        }, {
          onConflict: 'user_id,name',
        });
    }
  }
}

function formatKnowledgeBase(kb: KnowledgeBase): string {
  let result = '';
  
  const charCount = Object.keys(kb.characters).length;
  const eventCount = Object.keys(kb.events).length;
  const topicCount = Object.keys(kb.topics).length;
  
  if (charCount > 0) {
    result += 'üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:\n';
    Object.values(kb.characters).forEach(char => {
      result += `- ${char.name} (—É–ø–æ–º–∏–Ω–∞–Ω–∏–π: ${char.mentions})\n`;
      if (char.facts.length > 0) {
        result += `  –§–∞–∫—Ç—ã: ${char.facts.join(', ')}\n`;
      }
    });
    result += '\n';
  }
  
  if (eventCount > 0) {
    result += 'üìÖ –°–æ–±—ã—Ç–∏—è:\n';
    Object.values(kb.events).forEach(evt => {
      result += `- ${evt.name} (—É–ø–æ–º–∏–Ω–∞–Ω–∏–π: ${evt.mentions})\n`;
      if (evt.details.length > 0) {
        result += `  –î–µ—Ç–∞–ª–∏: ${evt.details.join(', ')}\n`;
      }
    });
    result += '\n';
  }
  
  if (topicCount > 0) {
    result += 'üí° –¢–µ–º—ã:\n';
    Object.values(kb.topics).forEach(topic => {
      result += `- ${topic.name} (—É–ø–æ–º–∏–Ω–∞–Ω–∏–π: ${topic.mentions})\n`;
      if (topic.info.length > 0) {
        result += `  –ò–Ω—Ñ–æ: ${topic.info.join(', ')}\n`;
      }
    });
    result += '\n';
  }
  
  if (charCount === 0 && eventCount === 0 && topicCount === 0) {
    result = '–ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π –ø—É—Å—Ç–∞. –ù–∞—á–Ω–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä, —á—Ç–æ–±—ã —è –º–æ–≥ –∑–∞–ø–æ–º–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–±–µ!';
  }
  
  return result;
}

function generateSummary(kb: KnowledgeBase, target: string): string {
  if (target === 'all') {
    const charCount = Object.keys(kb.characters).length;
    const eventCount = Object.keys(kb.events).length;
    return `üìä –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n` +
           `üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π: ${charCount}\n` +
           `üìÖ –°–æ–±—ã—Ç–∏—è: ${eventCount}\n\n` +
           `–ò—Å–ø–æ–ª—å–∑—É–π /summary [–∏–º—è] –¥–ª—è –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–µ–π.`;
  }

  if (kb.characters[target]) {
    const char = kb.characters[target];
    return `üë§ ${target}\n\n` +
           `–£–ø–æ–º–∏–Ω–∞–Ω–∏–π: ${char.mentions}\n` +
           `–§–∞–∫—Ç—ã: ${char.facts.length > 0 ? char.facts.join(', ') : '–ü–æ–∫–∞ –Ω–µ—Ç —Ñ–∞–∫—Ç–æ–≤'}`;
  }

  return `–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ "${target}" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π /summary all`;
}

function generateFacts(kb: KnowledgeBase, target: string): string {
  if (target === 'all') {
    let result = 'üìù –í—Å–µ —Ñ–∞–∫—Ç—ã:\n\n';
    Object.entries(kb.characters).forEach(([name, data]) => {
      if (data.facts.length > 0) {
        result += `${name}: ${data.facts.join(', ')}\n`;
      }
    });
    return result || '–§–∞–∫—Ç–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç.';
  }

  if (kb.characters[target]) {
    const facts = kb.characters[target].facts;
    return facts.length > 0 
      ? `–§–∞–∫—Ç—ã –æ ${target}:\n${facts.join('\n')}`
      : `–§–∞–∫—Ç–æ–≤ –æ ${target} –ø–æ–∫–∞ –Ω–µ—Ç.`;
  }

  return `–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ "${target}" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`;
}

async function createCharacter(supabase: any, userId: string, params: string): Promise<string> {
  const parts = params.split('|').map(p => p.trim());
  if (parts.length < 2) {
    return '‚ùå –§–æ—Ä–º–∞—Ç: /create <–∏–º—è> | <–æ–ø–∏—Å–∞–Ω–∏–µ> | [–∫–∞—Ç–µ–≥–æ—Ä–∏—è] | [—Å—Ç–∏–ª—å —Ä–µ—á–∏]';
  }

  const [name, description, category = 'general', speakingStyle = ''] = parts;
  
  const { error } = await supabase
    .from('characters')
    .insert({
      user_id: userId,
      name,
      facts: [description],
      category,
      personality: description,
      speaking_style: speakingStyle,
      mentions: 0,
    });

  if (error) {
    console.error('Error creating character:', error);
    return `‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞: ${error.message}`;
  }

  return `‚úÖ –ü–µ—Ä—Å–æ–Ω–∞–∂ "${name}" —Å–æ–∑–¥–∞–Ω!\n–û–ø–∏—Å–∞–Ω–∏–µ: ${description}\n–ö–∞—Ç–µ–≥–æ—Ä–∏—è: ${category}`;
}

async function createLink(supabase: any, userId: string, params: string, kb: KnowledgeBase): Promise<string> {
  const match = params.match(/(.+?)\s*>\s*(.+?)\s+(.+)/);
  if (!match) {
    return '‚ùå –§–æ—Ä–º–∞—Ç: /link <–æ—Ç> > <–∫> <—Ç–∏–ø —Å–≤—è–∑–∏> [–æ–ø–∏—Å–∞–Ω–∏–µ]';
  }

  const [, fromName, toName, rest] = match;
  const [relationType, ...descParts] = rest.trim().split(' ');
  const description = descParts.join(' ');

  // Find character IDs
  const { data: fromChar } = await supabase
    .from('characters')
    .select('id')
    .eq('user_id', userId)
    .eq('name', fromName.trim())
    .single();

  const { data: toChar } = await supabase
    .from('characters')
    .select('id')
    .eq('user_id', userId)
    .eq('name', toName.trim())
    .single();

  if (!fromChar || !toChar) {
    return `‚ùå –û–¥–∏–Ω –∏–∑ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –∏—Ö –∫–æ–º–∞–Ω–¥–æ–π /create`;
  }

  const { error } = await supabase
    .from('relationships')
    .insert({
      user_id: userId,
      from_character_id: fromChar.id,
      to_character_id: toChar.id,
      relationship_type: relationType,
      description: description || '',
      strength: 5,
    });

  if (error) {
    console.error('Error creating relationship:', error);
    return `‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–≤—è–∑–∏: ${error.message}`;
  }

  return `‚úÖ –°–≤—è–∑—å —Å–æ–∑–¥–∞–Ω–∞: ${fromName} > ${toName} (${relationType})`;
}

function analyzeGraph(kb: KnowledgeBase): string {
  const charCount = Object.keys(kb.characters).length;
  const relCount = kb.relationships.length;

  if (charCount === 0) {
    return '‚ùå –ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π –ø—É—Å—Ç–∞. –°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –∫–æ–º–∞–Ω–¥–æ–π /create';
  }

  let result = `üìä –ê–Ω–∞–ª–∏–∑ –≥—Ä–∞—Ñ–∞ —Å–≤—è–∑–µ–π\n\n`;
  result += `üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π: ${charCount}\n`;
  result += `üîó –°–≤—è–∑–µ–π: ${relCount}\n\n`;

  // Find most connected characters
  const connections: { [key: string]: number } = {};
  kb.relationships.forEach(rel => {
    connections[rel.from_character] = (connections[rel.from_character] || 0) + 1;
    connections[rel.to_character] = (connections[rel.to_character] || 0) + 1;
  });

  const sorted = Object.entries(connections).sort((a, b) => b[1] - a[1]);
  
  if (sorted.length > 0) {
    result += `üåü –°–∞–º—ã–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ:\n`;
    sorted.slice(0, 3).forEach(([name, count]) => {
      result += `- ${name}: ${count} —Å–≤—è–∑–µ–π\n`;
    });
  }

  result += `\nüìã –¢–∏–ø—ã —Å–≤—è–∑–µ–π:\n`;
  const relTypes: { [key: string]: number } = {};
  kb.relationships.forEach(rel => {
    relTypes[rel.type] = (relTypes[rel.type] || 0) + 1;
  });
  
  Object.entries(relTypes).forEach(([type, count]) => {
    result += `- ${type}: ${count}\n`;
  });

  return result;
}

async function generateCharacterPrompt(
  supabase: any,
  userId: string,
  characterName: string,
  kb: KnowledgeBase
): Promise<string> {
  const { data: character } = await supabase
    .from('characters')
    .select('*')
    .eq('user_id', userId)
    .eq('name', characterName)
    .single();

  if (!character) {
    return `–ü–µ—Ä—Å–æ–Ω–∞–∂ "${characterName}" –Ω–µ –Ω–∞–π–¥–µ–Ω.`;
  }

  const relationships = kb.relationships.filter(
    rel => rel.from_character === characterName || rel.to_character === characterName
  );

  let prompt = `–¢—ã –∏–≥—Ä–∞–µ—à—å —Ä–æ–ª—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞: ${character.name}\n\n`;
  prompt += `üé≠ –õ–∏—á–Ω–æ—Å—Ç—å: ${character.personality || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}\n`;
  
  if (character.speaking_style) {
    prompt += `üó£Ô∏è –°—Ç–∏–ª—å —Ä–µ—á–∏: ${character.speaking_style}\n`;
  }

  if (character.facts && character.facts.length > 0) {
    prompt += `\nüìù –§–∞–∫—Ç—ã –æ —Ç–µ–±–µ:\n${character.facts.map((f: string) => `- ${f}`).join('\n')}\n`;
  }

  if (relationships.length > 0) {
    prompt += `\nüîó –¢–≤–æ–∏ —Å–≤—è–∑–∏:\n`;
    relationships.forEach(rel => {
      if (rel.from_character === characterName) {
        prompt += `- ${rel.to_character}: ${rel.type} (${rel.description})\n`;
      } else {
        prompt += `- ${rel.from_character}: ${rel.type} (${rel.description})\n`;
      }
    });
  }

  prompt += `\nüí¨ –û–±—â–∞–π—Å—è –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞, –æ—Å—Ç–∞–≤–∞–π—Å—è –≤ –æ–±—Ä–∞–∑–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ –∏—Å–ø–æ–ª—å–∑—É–π –µ–≥–æ —Å—Ç–∏–ª—å —Ä–µ—á–∏.`;

  return prompt;
}
